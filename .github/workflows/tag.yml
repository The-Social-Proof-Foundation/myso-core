name: Tag

on:
  repository_dispatch:
    types: [tag-main]

  workflow_call:
    inputs:
      myso_commit:
        description: 'MySo repo commit to tag'
        type: string
        required: true
      tag_name:
        description: 'Tag Name'
        type: string
        required: true
  workflow_dispatch:
    inputs:
      myso_commit:
        description: 'MySo repo commit to tag'
        type: string
        required: true
      tag_name:
        description: 'Tag Name'
        type: string
        required: true

permissions:
  contents: write

env:
  MYSO_COMMIT: "${{ github.event.client_payload.myso_commit || inputs.myso_commit }}"
  TAG_NAME: "${{ github.event.client_payload.tag_name || inputs.tag_name }}"

jobs:
  tag:
    name: Tag
    runs-on: ubuntu-latest

    steps:
    - name: Validate inputs
      run: |
        set -euo pipefail

        # Reject reserved branch names that could cause confusion (case-insensitive)
        TAG_NAME_LOWER="${TAG_NAME,,}"
        if [[ "$TAG_NAME_LOWER" =~ ^(main|master|head|develop|release)$ ]]; then
          echo "Error: '$TAG_NAME' is a reserved name, cannot use as tag"
          exit 1
        fi

        # Ensure tag name is not empty
        if [[ -z "$TAG_NAME" ]]; then
          echo "Error: TAG_NAME cannot be empty"
          exit 1
        fi

        # Validate SHA format (40 hex characters, case-insensitive)
        if [[ ! "$MYSO_COMMIT" =~ ^[a-fA-F0-9]{40}$ ]]; then
          echo "Error: MYSO_COMMIT must be a valid 40-character SHA, got: '$MYSO_COMMIT'"
          exit 1
        fi

        echo "Inputs validated: TAG_NAME='$TAG_NAME', MYSO_COMMIT='$MYSO_COMMIT'"

    - name: Checkout repository
      uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # pin@v6.0.2
      with:
        fetch-depth: 0
        token: ${{ secrets.MYSO_CREATE_RELEASE }}

    - name: Safety checks
      run: |
        set -euo pipefail

        # Verify commit exists in the repository
        if ! git cat-file -e "$MYSO_COMMIT^{commit}" 2>/dev/null; then
          echo "Error: Commit $MYSO_COMMIT does not exist in the repository"
          exit 1
        fi

        # Check if we're overwriting an existing tag
        if git rev-parse "refs/tags/$TAG_NAME" >/dev/null 2>&1; then
          OLD_SHA=$(git rev-parse "refs/tags/$TAG_NAME")
          echo "Warning: Tag '$TAG_NAME' already exists, pointing to $OLD_SHA"
          echo "Will update to point to $MYSO_COMMIT"
        else
          echo "Creating new tag '$TAG_NAME'"
        fi

        # Verify commit is reachable from main or a releases branch
        if ! git branch -r --contains "$MYSO_COMMIT" 2>/dev/null | grep -qE 'origin/(main$|releases/)'; then
          echo "Error: Commit $MYSO_COMMIT is not on main or a releases/ branch"
          echo "Reachable from branches:"
          git branch -r --contains "$MYSO_COMMIT" 2>/dev/null || echo "  (none)"
          exit 1
        fi

        echo "Safety checks passed"

    - name: Create or update tag
      run: |
        set -euo pipefail

        echo "Creating/updating tag $TAG_NAME to point to $MYSO_COMMIT"
        git tag -f "$TAG_NAME" "$MYSO_COMMIT"
        git push origin "$TAG_NAME" --force
        echo "Tag $TAG_NAME now points to $MYSO_COMMIT"
